// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search_products.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, description, category_id, price_units, price_currency, sku, active, stock_quantity, created_at, updated_at,
       ts_rank(product_search_vector, plainto_tsquery($1)) AS rank
FROM catalog.products
WHERE deleted_at IS NULL
  AND ($2::uuid IS NULL OR category_id = $2)
  AND ($3::bigint IS NULL OR price_units >= $3)
  AND ($4::bigint IS NULL OR price_units <= $4)
  AND ($5::boolean IS NULL OR (in_stock_only = false OR stock_quantity > 0))
  AND product_search_vector @@ plainto_tsquery($1)
ORDER BY rank ASC, created_at DESC
LIMIT $7 OFFSET $6
`

type SearchProductsParams struct {
	Query       *string     `json:"query"`
	CategoryID  pgtype.UUID `json:"category_id"`
	MinPrice    *int64      `json:"min_price"`
	MaxPrice    *int64      `json:"max_price"`
	InStockOnly *bool       `json:"in_stock_only"`
	Offset      *int32      `json:"offset"`
	Limit       *int32      `json:"limit"`
}

type SearchProductsRow struct {
	ID            pgtype.UUID      `json:"id"`
	Name          string           `json:"name"`
	Description   *string          `json:"description"`
	CategoryID    pgtype.UUID      `json:"category_id"`
	PriceUnits    int64            `json:"price_units"`
	PriceCurrency string           `json:"price_currency"`
	Sku           string           `json:"sku"`
	Active        *bool            `json:"active"`
	StockQuantity *int32           `json:"stock_quantity"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	Rank          float32          `json:"rank"`
}

// Full-text search for products using PostgreSQL GIN indexes
// :query, :category_id, :min_price, :max_price, :in_stock_only, :limit, :offset
func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.Query,
		arg.CategoryID,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchProductsRow{}
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.PriceUnits,
			&i.PriceCurrency,
			&i.Sku,
			&i.Active,
			&i.StockQuantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
